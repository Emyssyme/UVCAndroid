# Code Citations

## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
**Bingo!** Am găsit problema! Cit-i linia 856-870:  

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**Probleme
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```


## License: Apache-2.0
https://github.com/shiyinghan/UVCAndroid/blob/34de7c5afaf1e3e63c5519666adce3fefa916887/libuvccamera/src/main/jni/UVCCamera/UVCPreview.cpp

```
OK! Codul **pare corect**: 
1. NV12 frame vine
2. Se convertește NV12 → RGBX (1920×1080 sau 3840×2160)
3. Se pasteaza în preview via `draw_preview_one(frame, &mPreviewWindow)` — unde frame-ul e RGBX acum

Dar **cred că am găsit adevărata problemă**. Cit-i linia 781 -> `frame = get_frame(...)` — allocheaza NOU buffer pentru **RGBX CONVERTIT**. Dar după conversia NV12→RGBX, frame-ul are deja formatul corect. 

**Problema reală** poate fi în:
1. **Conversie slabă** — `uvc_nv12_to_rgbx()` implementare
2. **Buffer reuse** — frame-ul convertit e reutilizat fără reinitializare
3. **Aliasing** — frame->width, frame->height nu se sincronizeaza după converzie

Dar... stai. Re-cit-i `copyToSurface()` de la linia 856.  Acum văd, frame-ul e **RGBX** (4 bytes/pixel), deci `memcpy()` trebuie să fie corect. EXCEPT:

```cpp
if (frame->width >= buffer.stride) {
    memcpy(buffer.bits, frame->data,
           buffer.width * buffer.height * PREVIEW_PIXEL_BYTES);  // Aci!
} else {
    for (int i = 0; i < buffer.height; i++) {
        memcpy((uint8_t *) buffer.bits + i * buffer.stride * PREVIEW_PIXEL_BYTES,
               (uint8_t *) frame->data + i * buffer.width * PREVIEW_PIXEL_BYTES,
               buffer.width * PREVIEW_PIXEL_BYTES);
    }
}
```

**RED
```

